<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A `Producer` is effectively a “splittable `IntoIterator`”. That is, a producer is a value which can be converted into an iterator at any time: at that point, it simply produces items on demand, like any iterator. But what makes a `Producer` special is that, before we convert to an iterator, we can also split it at a particular point using the `split_at` method. This will yield up two producers, one producing the items before that point, and one producing the items after that point (these two producers can then independently be split further, or be converted into iterators). In Rayon, this splitting is used to divide between threads. See the `plumbing` README for further details."><title>Producer in rayon::iter::plumbing - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="rayon" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (8f359beca 2024-02-23)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-c37d3936c59ababd.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

<style>
  code.code-math {
      background-color: transparent;
  }
</style>

<script>
  'use strict';

  const macros = {
    // '\\foo': '42',
    // '\\bar': '\\operatorname{bar}^{#1}',
    '\\halfopen': '[#1, #2)',
    '\\floor': '\\lfloor #1\\rfloor',
    '\\ceil': '\\lceil #1\\rceil',
    '\\rounded': '\\lfloor #1\\rceil',
    '\\Floor': '\\left\\lfloor #1\\right\\rfloor',
    '\\Ceil': '\\left\\lceil #1\\right\\rceil',
    '\\Rounded': '\\left\\lfloor #1\\right\\rceil',
    '\\angled': '\\langle #1\\rangle',
    '\\Angled': '\\left\\langle #1\\right\\rangle',
    '\\lcm': '\\operatorname*{lcm}',
    '\\gcd': '\\operatorname*{gcd}',
    '\\poly': '\\operatorname{poly}',
    '\\polylog': '\\operatorname{polylog}',
    '\\concat': '\\mathrel{+\\!\\!+}',
    '\\mex': '\\operatorname*{mex}',
    '\\qed': '\\square',
    '\\Q': '\\mathbb{Q}',
    '\\dd': '\\mathrm{d}',
    '\\ForallL': '{}^{\\forall}#1.\\:#2',
    '\\Forall': '{}^{\\forall}#1.\\,\\left[#2\\right]',
    '\\ExistsL': '{}^{\\exists}#1.\\:#2',
    '\\Exists': '{}^{\\exists}#1.\\,\\left[#2\\right]',
    '\\roundp': '(\\kern-.2em[#1]\\kern-.2em)',
    '\\bigroundp': '\\big(\\kern-.25em\\big[#1\\big]\\kern-.25em\\big)',
    '\\Bigroundp': '\\Big(\\kern-.3em\\Big[#1\\Big]\\kern-.3em\\Big)',
    '\\biggroundp': '\\bigg(\\kern-.3em\\bigg[#1\\bigg]\\kern-.3em\\bigg)',
    '\\Biggroundp': '\\Bigg(\\kern-.35em\\Bigg[#1\\Bigg]\\kern-.35em\\Bigg)',
    '\\hfloor': '\\lfloor\\hspace{-.25em}\\lfloor#1\\rfloor\\hspace{-.25em}\\rfloor',
    '\\xgets': '\\xleftarrow{#1}',
    '\\eod': '\\blacksquare', // end of \<details\>
    '\\lldot': '\\mathop{.\\,.}',
    '\\dp': '\\mathrm{dp}',
  };

  document.addEventListener('DOMContentLoaded', () => {
    const maths = document.getElementsByClassName('language-math');
    for (const elt of maths) {
      katex.render(elt.innerText, elt, { displayMode: true, macros });
    }

    const codes = Array.from(document.getElementsByTagName('code'));
    for (const elt of codes) {
      if (elt.classList.contains('language-math')) continue;
      if (elt.classList.contains('language-inline-math')) {
        katex.render(elt.innerText, elt, { macros });
        continue;
      }

      const parent = elt.parentNode;
      if (parent.nodeName.toLowerCase() === 'pre') {
        continue;
      }

      parent.style.overflowX = 'unset';
      const content = parent.outerHTML.replaceAll(
        /\$<code>([^<]*?)<\/code>\$/g,
        ((match, inner) => {
          return `<code class="code-math">${katex.renderToString(inner, { macros })}</code>`;
        }),
      );

      try {
        parent.outerHTML = content;
      } catch (DOMException) {
        continue;
      }
    }
  });
</script>

<script>
  'use strict';

  const cratesLs = {
    "algo": [
      "bisect",
      "tortoise_hare"
    ],
    "corro": [
      "borrow"
    ],
    "discussion": [
      "dp",
      "plane-sweep"
    ],
    "ds": [
      "foldable_deque",
      "foldable_queue",
      "rs01_dict",
      "union-find",
      "vec_segtree"
    ],
    "fmt": [
      "str_sep",
      "yes_no"
    ],
    "graph": [
      "bfs01",
      "dijkstra",
      "scc"
    ],
    "inner": [],
    "integer": [
      "bin_iter",
      "pdep_pext"
    ],
    "io": [
      "input",
      "readable"
    ],
    "macros": [],
    "math": [
      "divisors",
      "factors",
      "gcd",
      "linear_sieve",
      "modint"
    ],
    "naive": [
      "assoc-list",
      "bit-vector",
      "concat-monoid",
      "disjoint-set"
    ],
    "ops": [
      "monoid",
      "op_add",
      "usize_bounds"
    ],
    "poc": [
      "katex-support"
    ],
    "random": [
      "randgen"
    ],
    "seq": [
      "inversion",
      "lis",
      "majority_vote",
      "suffix_array"
    ],
    "snippet": [
      "proconio"
    ],
    "uslice": [
      "bucket_sort",
      "permutation"
    ]
  };

  document.addEventListener('DOMContentLoaded', () => {
    const crates = [...document.getElementsByClassName('block crate')][0];

    const links = new Map([...crates.querySelectorAll('a')].map((e) => [
      e.innerText,
      {
        name: e.innerText,
        href: e.href,
        current: e.parentNode.classList.contains('current'),
      },
    ]));

    const tree = new Map();
    for (const mod of Object.keys(cratesLs)) {
      for (const crate of cratesLs[mod]) {
        const crate_ = crate.replaceAll('-', '_');
        if (!links.has(crate_)) continue;

        if (!tree.has(mod)) {
          tree.set(mod, []);
        }

        tree.get(mod).push(links.get(crate_));
      }
    }

    const cratesElt = document.createElement('ul');
    cratesElt.classList.add('block');
    cratesElt.classList.add('crate');
    for (const [modName, mod] of tree) {
      {
        const li = document.createElement('li');
        const a = document.createElement('a');
        const link = links.get(modName);
        a.href = link.href;
        if (link.current) li.classList.add('current');
        a.innerText = link.name;
        li.appendChild(a);
        cratesElt.appendChild(li);
      }

      const ul = document.createElement('ul');
      for (const crate of mod) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = crate.href;
        if (crate.current) li.classList.add('current');
        a.innerText = crate.name;
        li.appendChild(a);
        ul.appendChild(li);
      }
      cratesElt.appendChild(ul);
    }

    crates.outerHTML = cratesElt.outerHTML;
  });
</script>

</head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../rayon/index.html">rayon</a><span class="version">1.8.1</span></h2></div><h2 class="location"><a href="#">Producer</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.IntoIter">IntoIter</a></li><li><a href="#associatedtype.Item">Item</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.into_iter">into_iter</a></li><li><a href="#tymethod.split_at">split_at</a></li></ul><h3><a href="#provided-methods">Provided Methods</a></h3><ul class="block"><li><a href="#method.fold_with">fold_with</a></li><li><a href="#method.max_len">max_len</a></li><li><a href="#method.min_len">min_len</a></li></ul><h3><a href="#object-safety">Object Safety</a></h3><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In rayon::iter::plumbing</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../../rayon/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="../../index.html">rayon</a>::<wbr><a href="../index.html">iter</a>::<wbr><a href="index.html">plumbing</a>::<wbr><a class="trait" href="#">Producer</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/rayon/iter/plumbing/mod.rs.html#59-112">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait Producer: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a> {
    type <a href="#associatedtype.Item" class="associatedtype">Item</a>;
    type <a href="#associatedtype.IntoIter" class="associatedtype">IntoIter</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = Self::<a class="associatedtype" href="trait.Producer.html#associatedtype.Item" title="type rayon::iter::plumbing::Producer::Item">Item</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator">DoubleEndedIterator</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/exact_size/trait.ExactSizeIterator.html" title="trait core::iter::traits::exact_size::ExactSizeIterator">ExactSizeIterator</a>;

    // Required methods
    fn <a href="#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="trait.Producer.html#associatedtype.IntoIter" title="type rayon::iter::plumbing::Producer::IntoIter">IntoIter</a>;
<span class="item-spacer"></span>    fn <a href="#tymethod.split_at" class="fn">split_at</a>(self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(Self, Self)</a>;

    // Provided methods
    fn <a href="#method.min_len" class="fn">min_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.max_len" class="fn">max_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> { ... }
<span class="item-spacer"></span>    fn <a href="#method.fold_with" class="fn">fold_with</a>&lt;F&gt;(self, folder: F) -&gt; F
       <span class="where">where F: <a class="trait" href="trait.Folder.html" title="trait rayon::iter::plumbing::Folder">Folder</a>&lt;Self::<a class="associatedtype" href="trait.Producer.html#associatedtype.Item" title="type rayon::iter::plumbing::Producer::Item">Item</a>&gt;</span> { ... }
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A <code>Producer</code> is effectively a “splittable <code>IntoIterator</code>”. That
is, a producer is a value which can be converted into an iterator
at any time: at that point, it simply produces items on demand,
like any iterator. But what makes a <code>Producer</code> special is that,
<em>before</em> we convert to an iterator, we can also <strong>split</strong> it at a
particular point using the <code>split_at</code> method. This will yield up
two producers, one producing the items before that point, and one
producing the items after that point (these two producers can then
independently be split further, or be converted into iterators).
In Rayon, this splitting is used to divide between threads.
See <a href="https://github.com/rayon-rs/rayon/blob/master/src/iter/plumbing/README.md">the <code>plumbing</code> README</a> for further details.</p>
<p>Note that each producer will always produce a fixed number of
items N. However, this number N is not queryable through the API;
the consumer is expected to track it.</p>
<p>NB. You might expect <code>Producer</code> to extend the <code>IntoIterator</code>
trait.  However, <a href="https://github.com/rust-lang/rust/issues/20671">rust-lang/rust#20671</a> prevents us from
declaring the DoubleEndedIterator and ExactSizeIterator
constraints on a required IntoIterator trait, so we inline
IntoIterator here until that issue is fixed.</p>
</div></details><h2 id="required-associated-types" class="section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Item" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#62">source</a><h4 class="code-header">type <a href="#associatedtype.Item" class="associatedtype">Item</a></h4></section></summary><div class="docblock"><p>The type of item that will be produced by this producer once
it is converted into an iterator.</p>
</div></details><details class="toggle" open><summary><section id="associatedtype.IntoIter" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#65">source</a><h4 class="code-header">type <a href="#associatedtype.IntoIter" class="associatedtype">IntoIter</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/iterator/trait.Iterator.html" title="trait core::iter::traits::iterator::Iterator">Iterator</a>&lt;Item = Self::<a class="associatedtype" href="trait.Producer.html#associatedtype.Item" title="type rayon::iter::plumbing::Producer::Item">Item</a>&gt; + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/double_ended/trait.DoubleEndedIterator.html" title="trait core::iter::traits::double_ended::DoubleEndedIterator">DoubleEndedIterator</a> + <a class="trait" href="https://doc.rust-lang.org/nightly/core/iter/traits/exact_size/trait.ExactSizeIterator.html" title="trait core::iter::traits::exact_size::ExactSizeIterator">ExactSizeIterator</a></h4></section></summary><div class="docblock"><p>The type of iterator we will become.</p>
</div></details></div><h2 id="required-methods" class="section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.into_iter" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#69">source</a><h4 class="code-header">fn <a href="#tymethod.into_iter" class="fn">into_iter</a>(self) -&gt; Self::<a class="associatedtype" href="trait.Producer.html#associatedtype.IntoIter" title="type rayon::iter::plumbing::Producer::IntoIter">IntoIter</a></h4></section></summary><div class="docblock"><p>Convert <code>self</code> into an iterator; at this point, no more parallel splits
are possible.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="tymethod.split_at" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#100">source</a><h4 class="code-header">fn <a href="#tymethod.split_at" class="fn">split_at</a>(self, index: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(Self, Self)</a></h4></section></summary><div class="docblock"><p>Split into two producers; one produces items <code>0..index</code>, the
other <code>index..N</code>. Index must be less than or equal to <code>N</code>.</p>
</div></details></div><h2 id="provided-methods" class="section-header">Provided Methods<a href="#provided-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="method.min_len" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#81-83">source</a><h4 class="code-header">fn <a href="#method.min_len" class="fn">min_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>The minimum number of items that we will process
sequentially. Defaults to 1, which means that we will split
all the way down to a single item. This can be raised higher
using the <a href="../trait.IndexedParallelIterator.html#method.with_min_len"><code>with_min_len</code></a> method, which will force us to
create sequential tasks at a larger granularity. Note that
Rayon automatically normally attempts to adjust the size of
parallel splits to reduce overhead, so this should not be
needed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.max_len" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#94-96">source</a><h4 class="code-header">fn <a href="#method.max_len" class="fn">max_len</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>The maximum number of items that we will process
sequentially. Defaults to MAX, which means that we can choose
not to split at all. This can be lowered using the
<a href="../trait.IndexedParallelIterator.html#method.with_max_len"><code>with_max_len</code></a> method, which will force us to create more
parallel tasks. Note that Rayon automatically normally
attempts to adjust the size of parallel splits to reduce
overhead, so this should not be needed.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.fold_with" class="method"><a class="src rightside" href="../../../src/rayon/iter/plumbing/mod.rs.html#106-111">source</a><h4 class="code-header">fn <a href="#method.fold_with" class="fn">fold_with</a>&lt;F&gt;(self, folder: F) -&gt; F<div class="where">where
    F: <a class="trait" href="trait.Folder.html" title="trait rayon::iter::plumbing::Folder">Folder</a>&lt;Self::<a class="associatedtype" href="trait.Producer.html#associatedtype.Item" title="type rayon::iter::plumbing::Producer::Item">Item</a>&gt;,</div></h4></section></summary><div class="docblock"><p>Iterate the producer, feeding each element to <code>folder</code>, and
stop when the folder is full (or all elements have been consumed).</p>
<p>The provided implementation is sufficient for most iterables.</p>
</div></details></div><h2 id="object-safety" class="section-header">Object Safety<a href="#object-safety" class="anchor">§</a></h2><div class="object-safety-info">This trait is <b>not</b> <a href="https://doc.rust-lang.org/nightly/reference/items/traits.html#object-safety">object safe</a>.</div><h2 id="implementors" class="section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"></div><script src="../../../trait.impl/rayon/iter/plumbing/trait.Producer.js" async></script></section></div></main></body></html>