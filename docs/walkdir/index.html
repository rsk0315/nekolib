<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Crate `walkdir` provides an efficient and cross platform implementation of recursive directory traversal. Several options are exposed to control iteration, such as whether to follow symbolic links (default off), limit the maximum number of simultaneous open file descriptors and the ability to efficiently skip descending into directories."><title>walkdir - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-e935ef01ae1c1829.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="walkdir" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (381d69953 2024-02-24)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-4c98445ec4002617.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-c37d3936c59ababd.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

<style>
  code.code-math {
      background-color: transparent;
  }
</style>

<script>
  'use strict';

  const macros = {
    // '\\foo': '42',
    // '\\bar': '\\operatorname{bar}^{#1}',
    '\\halfopen': '[#1, #2)',
    '\\floor': '\\lfloor #1\\rfloor',
    '\\ceil': '\\lceil #1\\rceil',
    '\\rounded': '\\lfloor #1\\rceil',
    '\\Floor': '\\left\\lfloor #1\\right\\rfloor',
    '\\Ceil': '\\left\\lceil #1\\right\\rceil',
    '\\Rounded': '\\left\\lfloor #1\\right\\rceil',
    '\\angled': '\\langle #1\\rangle',
    '\\Angled': '\\left\\langle #1\\right\\rangle',
    '\\lcm': '\\operatorname*{lcm}',
    '\\gcd': '\\operatorname*{gcd}',
    '\\poly': '\\operatorname{poly}',
    '\\polylog': '\\operatorname{polylog}',
    '\\concat': '\\mathrel{+\\!\\!+}',
    '\\mex': '\\operatorname*{mex}',
    '\\qed': '\\square',
    '\\Q': '\\mathbb{Q}',
    '\\dd': '\\mathrm{d}',
    '\\ForallL': '{}^{\\forall}#1.\\:#2',
    '\\Forall': '{}^{\\forall}#1.\\,\\left[#2\\right]',
    '\\ExistsL': '{}^{\\exists}#1.\\:#2',
    '\\Exists': '{}^{\\exists}#1.\\,\\left[#2\\right]',
    '\\roundp': '(\\kern-.2em[#1]\\kern-.2em)',
    '\\bigroundp': '\\big(\\kern-.25em\\big[#1\\big]\\kern-.25em\\big)',
    '\\Bigroundp': '\\Big(\\kern-.3em\\Big[#1\\Big]\\kern-.3em\\Big)',
    '\\biggroundp': '\\bigg(\\kern-.3em\\bigg[#1\\bigg]\\kern-.3em\\bigg)',
    '\\Biggroundp': '\\Bigg(\\kern-.35em\\Bigg[#1\\Bigg]\\kern-.35em\\Bigg)',
    '\\hfloor': '\\lfloor\\hspace{-.25em}\\lfloor#1\\rfloor\\hspace{-.25em}\\rfloor',
    '\\xgets': '\\xleftarrow{#1}',
    '\\eod': '\\blacksquare', // end of \<details\>
    '\\lldot': '\\mathop{.\\,.}',
    '\\dp': '\\mathrm{dp}',
  };

  document.addEventListener('DOMContentLoaded', () => {
    const maths = document.getElementsByClassName('language-math');
    for (const elt of maths) {
      katex.render(elt.innerText, elt, { displayMode: true, macros });
    }

    const codes = Array.from(document.getElementsByTagName('code'));
    for (const elt of codes) {
      if (elt.classList.contains('language-math')) continue;
      if (elt.classList.contains('language-inline-math')) {
        katex.render(elt.innerText, elt, { macros });
        continue;
      }

      const parent = elt.parentNode;
      if (parent.nodeName.toLowerCase() === 'pre') {
        continue;
      }

      parent.style.overflowX = 'unset';
      const content = parent.outerHTML.replaceAll(
        /\$<code>([^<]*?)<\/code>\$/g,
        ((match, inner) => {
          return `<code class="code-math">${katex.renderToString(inner, { macros })}</code>`;
        }),
      );

      try {
        parent.outerHTML = content;
      } catch (DOMException) {
        continue;
      }
    }
  });
</script>

<script>
  'use strict';

  const cratesLs = {
    "algo": [
      "bisect",
      "tortoise_hare"
    ],
    "corro": [
      "borrow"
    ],
    "discussion": [
      "dp",
      "plane-sweep"
    ],
    "ds": [
      "foldable_deque",
      "foldable_queue",
      "rs01_dict",
      "union-find",
      "vec_segtree"
    ],
    "fmt": [
      "str_sep",
      "yes_no"
    ],
    "graph": [
      "bfs01",
      "dijkstra",
      "lowlink",
      "scc"
    ],
    "inner": [],
    "integer": [
      "bin_iter",
      "pdep_pext"
    ],
    "io": [
      "input",
      "readable"
    ],
    "macros": [],
    "math": [
      "divisors",
      "factors",
      "gcd",
      "linear_sieve",
      "modint"
    ],
    "naive": [
      "assoc-list",
      "bit-vector",
      "concat-monoid",
      "disjoint-set"
    ],
    "ops": [
      "monoid",
      "op_add",
      "usize_bounds"
    ],
    "poc": [
      "katex-support"
    ],
    "random": [
      "randgen"
    ],
    "seq": [
      "inversion",
      "lis",
      "majority_vote",
      "suffix_array"
    ],
    "snippet": [
      "proconio"
    ],
    "uslice": [
      "bucket_sort",
      "permutation"
    ]
  };

  document.addEventListener('DOMContentLoaded', () => {
    const crates = [...document.getElementsByClassName('block crate')][0];

    const links = new Map([...crates.querySelectorAll('a')].map((e) => [
      e.innerText,
      {
        name: e.innerText,
        href: e.href,
        current: e.parentNode.classList.contains('current'),
      },
    ]));

    const tree = new Map();
    for (const mod of Object.keys(cratesLs)) {
      for (const crate of cratesLs[mod]) {
        const crate_ = crate.replaceAll('-', '_');
        if (!links.has(crate_)) continue;

        if (!tree.has(mod)) {
          tree.set(mod, []);
        }

        tree.get(mod).push(links.get(crate_));
      }
    }

    const cratesElt = document.createElement('ul');
    cratesElt.classList.add('block');
    cratesElt.classList.add('crate');
    for (const [modName, mod] of tree) {
      {
        const li = document.createElement('li');
        const a = document.createElement('a');
        const link = links.get(modName);
        a.href = link.href;
        if (link.current) li.classList.add('current');
        a.innerText = link.name;
        li.appendChild(a);
        cratesElt.appendChild(li);
      }

      const ul = document.createElement('ul');
      for (const crate of mod) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = crate.href;
        if (crate.current) li.classList.add('current');
        a.innerText = crate.name;
        li.appendChild(a);
        ul.appendChild(li);
      }
      cratesElt.appendChild(ul);
    }

    crates.outerHTML = cratesElt.outerHTML;
  });
</script>

</head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../walkdir/index.html">walkdir</a><span class="version">2.4.0</span></h2></div><div class="sidebar-elems"><ul class="block">
            <li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Aliases</a></li></ul></section></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../walkdir/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">walkdir</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/walkdir/lib.rs.html#1-1186">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Crate <code>walkdir</code> provides an efficient and cross platform implementation
of recursive directory traversal. Several options are exposed to control
iteration, such as whether to follow symbolic links (default off), limit the
maximum number of simultaneous open file descriptors and the ability to
efficiently skip descending into directories.</p>
<p>To use this crate, add <code>walkdir</code> as a dependency to your project’s
<code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
walkdir = &quot;2&quot;
</code></pre></div><h2 id="from-the-top"><a class="doc-anchor" href="#from-the-top">§</a>From the top</h2>
<p>The <a href="struct.WalkDir.html"><code>WalkDir</code></a> type builds iterators. The <a href="struct.DirEntry.html"><code>DirEntry</code></a> type describes values
yielded by the iterator. Finally, the <a href="struct.Error.html"><code>Error</code></a> type is a small wrapper around
<a href="https://doc.rust-lang.org/stable/std/io/struct.Error.html"><code>std::io::Error</code></a> with additional information, such as if a loop was detected
while following symbolic links (not enabled by default).</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>The following code recursively iterates over the directory given and prints
the path for each entry:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>walkdir::WalkDir;

<span class="kw">for </span>entry <span class="kw">in </span>WalkDir::new(<span class="string">"foo"</span>) {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, entry<span class="question-mark">?</span>.path().display());
}</code></pre></div>
<p>Or, if you’d like to iterate over all entries and ignore any errors that
may arise, use <a href="https://doc.rust-lang.org/stable/std/iter/trait.Iterator.html#method.filter_map"><code>filter_map</code></a>. (e.g., This code below will silently skip
directories that the owner of the running process does not have permission to
access.)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>walkdir::WalkDir;

<span class="kw">for </span>entry <span class="kw">in </span>WalkDir::new(<span class="string">"foo"</span>).into_iter().filter_map(|e| e.ok()) {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, entry.path().display());
}</code></pre></div>
<h2 id="example-follow-symbolic-links"><a class="doc-anchor" href="#example-follow-symbolic-links">§</a>Example: follow symbolic links</h2>
<p>The same code as above, except <a href="struct.WalkDir.html#method.follow_links"><code>follow_links</code></a> is enabled:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>walkdir::WalkDir;

<span class="kw">for </span>entry <span class="kw">in </span>WalkDir::new(<span class="string">"foo"</span>).follow_links(<span class="bool-val">true</span>) {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, entry<span class="question-mark">?</span>.path().display());
}</code></pre></div>
<h2 id="example-skip-hidden-files-and-directories-on-unix"><a class="doc-anchor" href="#example-skip-hidden-files-and-directories-on-unix">§</a>Example: skip hidden files and directories on unix</h2>
<p>This uses the <a href="struct.IntoIter.html#method.filter_entry"><code>filter_entry</code></a> iterator adapter to avoid yielding hidden files
and directories efficiently (i.e. without recursing into hidden directories):</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>walkdir::{DirEntry, WalkDir};

<span class="kw">fn </span>is_hidden(entry: <span class="kw-2">&amp;</span>DirEntry) -&gt; bool {
    entry.file_name()
         .to_str()
         .map(|s| s.starts_with(<span class="string">"."</span>))
         .unwrap_or(<span class="bool-val">false</span>)
}

<span class="kw">let </span>walker = WalkDir::new(<span class="string">"foo"</span>).into_iter();
<span class="kw">for </span>entry <span class="kw">in </span>walker.filter_entry(|e| !is_hidden(e)) {
    <span class="macro">println!</span>(<span class="string">"{}"</span>, entry<span class="question-mark">?</span>.path().display());
}</code></pre></div>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DirEntry.html" title="struct walkdir::DirEntry">DirEntry</a></div><div class="desc docblock-short">A directory entry.</div></li><li><div class="item-name"><a class="struct" href="struct.Error.html" title="struct walkdir::Error">Error</a></div><div class="desc docblock-short">An error produced by recursively walking a directory.</div></li><li><div class="item-name"><a class="struct" href="struct.FilterEntry.html" title="struct walkdir::FilterEntry">FilterEntry</a></div><div class="desc docblock-short">A recursive directory iterator that skips entries.</div></li><li><div class="item-name"><a class="struct" href="struct.IntoIter.html" title="struct walkdir::IntoIter">IntoIter</a></div><div class="desc docblock-short">An iterator for recursively descending into a directory.</div></li><li><div class="item-name"><a class="struct" href="struct.WalkDir.html" title="struct walkdir::WalkDir">WalkDir</a></div><div class="desc docblock-short">A builder to create an iterator for recursively walking a directory.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.DirEntryExt.html" title="trait walkdir::DirEntryExt">DirEntryExt</a></div><div class="desc docblock-short">Unix-specific extension methods for <code>walkdir::DirEntry</code></div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Result.html" title="type walkdir::Result">Result</a></div><div class="desc docblock-short">A result type for walkdir operations.</div></li></ul></section></div></main></body></html>