<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Interface to the operating system’s random number generator."><title>getrandom - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-cb6f1f67f1bcd037.css" id="mainThemeStyle"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="getrandom" data-themes="" data-resource-suffix="" data-rustdoc-version="1.73.0-nightly (04abc370b 2023-07-28)" data-channel="nightly" data-search-js="search-6dfdfced5eff6596.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-6d2c9675f3d09c26.css" data-theme-dark-css="dark-45ceb8f2e522f4d1.css" data-theme-ayu-css="ayu-fd19013d6ce078bf.css" ><script src="../static.files/storage-db41da1a38ea3cb8.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-0795b7d26be81095.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-6d2c9675f3d09c26.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-45ceb8f2e522f4d1.css"><link rel="stylesheet" href="../static.files/noscript-cffde32267a19fd6.css"></noscript><link rel="icon" href="https://www.rust-lang.org/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

<script>
  'use strict';

  const macros = {
    // '\\foo': '42',
    // '\\bar': '\\operatorname{bar}^{#1}',
  };

  document.addEventListener('DOMContentLoaded', () => {
    const maths = document.getElementsByClassName('language-math');
    for (const elt of maths) {
      katex.render(elt.innerText, elt, { displayMode: true, macros });
    }

    const codes = Array.from(document.getElementsByTagName('code'));
    for (const elt of codes) {
      if (elt.classList.contains('language-math')) continue;
      if (elt.classList.contains('language-inline-math')) {
        katex.render(elt.innerText, elt, { macros });
        continue;
      }

      const parent = elt.parentNode;
      if (parent.nodeName.toLowerCase() === 'pre') {
        continue;
      }
      const inlineMath = `$${elt.outerHTML}$`;
      if (!parent.innerHTML.includes(inlineMath)) {
        continue;
      }

      const math = katex.renderToString(elt.innerHTML, { macros });
      parent.outerHTML = parent.outerHTML.replace(inlineMath, `<code>${math}</code>`);
    }
  });
</script>

<script>
  'use strict';

  const cratesLs = {
    "algo": [
      "bisect"
    ],
    "corro": [
      "borrow"
    ],
    "ds": [
      "foldable_queue",
      "union-find",
      "vec_segtree"
    ],
    "fmt": [
      "str_sep",
      "yes_no"
    ],
    "inner": [],
    "integer": [
      "bin_iter",
      "pdep_pext"
    ],
    "io": [
      "input",
      "readable"
    ],
    "macros": [],
    "math": [
      "modint"
    ],
    "naive": [
      "assoc-list",
      "disjoint-set"
    ],
    "ops": [
      "monoid",
      "op_add",
      "usize_bounds"
    ],
    "poc": [
      "katex-support"
    ],
    "random": [
      "randgen"
    ],
    "seq": [
      "inversion",
      "lis"
    ],
    "uslice": [
      "permutation"
    ]
  };

  document.addEventListener('DOMContentLoaded', () => {
    const crates = [...document.getElementsByClassName('block crate')][0];

    const links = new Map([...crates.querySelectorAll('a')].map((e) => [
      e.innerText,
      {
        name: e.innerText,
        href: e.href,
        current: e.classList.contains('current'),
      },
    ]));

    const tree = new Map();
    for (const mod of Object.keys(cratesLs)) {
      for (const crate of cratesLs[mod]) {
        const crate_ = crate.replaceAll('-', '_');
        if (!links.has(crate_)) continue;

        if (!tree.has(mod)) {
          tree.set(mod, []);
        }

        tree.get(mod).push(links.get(crate_));
      }
    }

    const cratesElt = document.createElement('ul');
    cratesElt.classList.add('block');
    cratesElt.classList.add('crate');
    for (const [modName, mod] of tree) {
      {
        const li = document.createElement('li');
        const a = document.createElement('a');
        const link = links.get(modName);
        a.href = link.href;
        if (link.current) a.classList.add('current');
        a.innerText = link.name;
        li.appendChild(a);
        cratesElt.appendChild(li);
      }

      const ul = document.createElement('ul');
      for (const crate of mod) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = crate.href;
        if (crate.current) a.classList.add('current');
        a.innerText = crate.name;
        li.appendChild(a);
        ul.appendChild(li);
      }
      cratesElt.appendChild(ul);
    }

    crates.outerHTML = cratesElt.outerHTML;
  });
</script>

</head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../getrandom/index.html"><img src="https://www.rust-lang.org/logos/rust-logo-128x128-blk.png" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../getrandom/index.html"><img src="https://www.rust-lang.org/logos/rust-logo-128x128-blk.png" alt="logo"></a><h2 class="location"><a href="#">Crate getrandom</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.2.10</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">getrandom</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/getrandom/lib.rs.html#9-346">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Interface to the operating system’s random number generator.</p>
<h2 id="supported-targets"><a href="#supported-targets">Supported targets</a></h2><div><table><thead><tr><th>Target</th><th>Target Triple</th><th>Implementation</th></tr></thead><tbody>
<tr><td>Linux, Android</td><td><code>*‑linux‑*</code></td><td><a href="http://man7.org/linux/man-pages/man2/getrandom.2.html"><code>getrandom</code></a> system call if available, otherwise <a href="http://man7.org/linux/man-pages/man4/urandom.4.html"><code>/dev/urandom</code></a> after successfully polling <code>/dev/random</code></td></tr>
<tr><td>Windows</td><td><code>*‑windows‑*</code></td><td><a href="https://docs.microsoft.com/en-us/windows/win32/api/bcrypt/nf-bcrypt-bcryptgenrandom"><code>BCryptGenRandom</code></a></td></tr>
<tr><td>macOS</td><td><code>*‑apple‑darwin</code></td><td><a href="https://www.unix.com/man-page/mojave/2/getentropy/"><code>getentropy</code></a> if available, otherwise <a href="https://www.unix.com/man-page/mojave/4/urandom/"><code>/dev/urandom</code></a> (identical to <code>/dev/random</code>)</td></tr>
<tr><td>iOS, tvOS, watchOS</td><td><code>*‑apple‑ios</code>, <code>*-apple-tvos</code>, <code>*-apple-watchos</code></td><td><a href="https://developer.apple.com/documentation/security/1399291-secrandomcopybytes?language=objc"><code>SecRandomCopyBytes</code></a></td></tr>
<tr><td>FreeBSD</td><td><code>*‑freebsd</code></td><td><a href="https://www.freebsd.org/cgi/man.cgi?query=getrandom&amp;manpath=FreeBSD+12.0-stable"><code>getrandom</code></a> if available, otherwise <a href="https://www.freebsd.org/cgi/man.cgi?query=random&amp;sektion=4"><code>kern.arandom</code></a></td></tr>
<tr><td>OpenBSD</td><td><code>*‑openbsd</code></td><td><a href="https://man.openbsd.org/getentropy.2"><code>getentropy</code></a></td></tr>
<tr><td>NetBSD</td><td><code>*‑netbsd</code></td><td><a href="https://man.netbsd.org/getrandom.2"><code>getrandom</code></a> if available, otherwise <a href="https://man.netbsd.org/sysctl.7"><code>kern.arandom</code></a></td></tr>
<tr><td>Dragonfly BSD</td><td><code>*‑dragonfly</code></td><td><a href="https://leaf.dragonflybsd.org/cgi/web-man?command=getrandom"><code>getrandom</code></a> if available, otherwise <a href="https://leaf.dragonflybsd.org/cgi/web-man?command=random&amp;section=4"><code>/dev/urandom</code></a> (identical to <code>/dev/random</code>)</td></tr>
<tr><td>Solaris, illumos</td><td><code>*‑solaris</code>, <code>*‑illumos</code></td><td><a href="https://docs.oracle.com/cd/E88353_01/html/E37841/getrandom-2.html"><code>getrandom</code></a> if available, otherwise <a href="https://docs.oracle.com/cd/E86824_01/html/E54777/random-7d.html"><code>/dev/random</code></a></td></tr>
<tr><td>Fuchsia OS</td><td><code>*‑fuchsia</code></td><td><a href="https://fuchsia.dev/fuchsia-src/zircon/syscalls/cprng_draw"><code>cprng_draw</code></a></td></tr>
<tr><td>Redox</td><td><code>*‑redox</code></td><td><code>/dev/urandom</code></td></tr>
<tr><td>Haiku</td><td><code>*‑haiku</code></td><td><code>/dev/urandom</code> (identical to <code>/dev/random</code>)</td></tr>
<tr><td>Hermit</td><td><code>*-hermit</code></td><td><a href="https://hermitcore.github.io/libhermit-rs/hermit/fn.sys_read_entropy.html"><code>sys_read_entropy</code></a></td></tr>
<tr><td>SGX</td><td><code>x86_64‑*‑sgx</code></td><td><a href="https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide"><code>RDRAND</code></a></td></tr>
<tr><td>VxWorks</td><td><code>*‑wrs‑vxworks‑*</code></td><td><code>randABytes</code> after checking entropy pool initialization with <code>randSecure</code></td></tr>
<tr><td>ESP-IDF</td><td><code>*‑espidf</code></td><td><a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/random.html#_CPPv415esp_fill_randomPv6size_t"><code>esp_fill_random</code></a></td></tr>
<tr><td>Emscripten</td><td><code>*‑emscripten</code></td><td><a href="https://github.com/emscripten-core/emscripten/pull/12240"><code>getentropy</code></a></td></tr>
<tr><td>WASI</td><td><code>wasm32‑wasi</code></td><td><a href="https://github.com/WebAssembly/WASI/blob/main/phases/snapshot/docs.md#-random_getbuf-pointeru8-buf_len-size---errno"><code>random_get</code></a></td></tr>
<tr><td>Web Browser and Node.js</td><td><code>wasm*‑*‑unknown</code></td><td><a href="https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues"><code>Crypto.getRandomValues</code></a> if available, then <a href="https://nodejs.org/api/crypto.html#cryptorandomfillsyncbuffer-offset-size"><code>crypto.randomFillSync</code></a> if on Node.js, see <a href="#webassembly-support">WebAssembly support</a></td></tr>
<tr><td>SOLID</td><td><code>*-kmc-solid_*</code></td><td><code>SOLID_RNG_SampleRandomBytes</code></td></tr>
<tr><td>Nintendo 3DS</td><td><code>armv6k-nintendo-3ds</code></td><td><a href="http://man7.org/linux/man-pages/man2/getrandom.2.html"><code>getrandom</code></a></td></tr>
<tr><td>PS Vita</td><td><code>armv7-sony-vita-newlibeabihf</code></td><td><a href="https://github.com/emscripten-core/emscripten/pull/12240"><code>getentropy</code></a></td></tr>
<tr><td>QNX Neutrino</td><td><code>*‑nto-qnx*</code></td><td><a href="https://www.qnx.com/developers/docs/7.1/index.html#com.qnx.doc.neutrino.utilities/topic/r/random.html"><code>/dev/urandom</code></a> (identical to <code>/dev/random</code>)</td></tr>
<tr><td>AIX</td><td><code>*-ibm-aix</code></td><td><a href="https://www.ibm.com/docs/en/aix/7.3?topic=files-random-urandom-devices"><code>/dev/urandom</code></a></td></tr>
</tbody></table>
</div>
<p>There is no blanket implementation on <code>unix</code> targets that reads from
<code>/dev/urandom</code>. This ensures all supported targets are using the recommended
interface and respect maximum buffer sizes.</p>
<p>Pull Requests that add support for new targets to <code>getrandom</code> are always welcome.</p>
<h3 id="unsupported-targets"><a href="#unsupported-targets">Unsupported targets</a></h3>
<p>By default, <code>getrandom</code> will not compile on unsupported targets, but certain
features allow a user to select a “fallback” implementation if no supported
implementation exists.</p>
<p>All of the below mechanisms only affect unsupported
targets. Supported targets will <em>always</em> use their supported implementations.
This prevents a crate from overriding a secure source of randomness
(either accidentally or intentionally).</p>
<h4 id="rdrand-on-x86"><a href="#rdrand-on-x86">RDRAND on x86</a></h4>
<p><em>If the <code>rdrand</code> Cargo feature is enabled</em>, <code>getrandom</code> will fallback to using
the <a href="https://software.intel.com/en-us/articles/intel-digital-random-number-generator-drng-software-implementation-guide"><code>RDRAND</code></a> instruction to get randomness on <code>no_std</code> <code>x86</code>/<code>x86_64</code>
targets. This feature has no effect on other CPU architectures.</p>
<h4 id="webassembly-support"><a href="#webassembly-support">WebAssembly support</a></h4>
<p>This crate fully supports the
<a href="https://github.com/CraneStation/wasi"><code>wasm32-wasi</code></a> and
<a href="https://www.hellorust.com/setup/emscripten/"><code>wasm32-unknown-emscripten</code></a>
targets. However, the <code>wasm32-unknown-unknown</code> target (i.e. the target used
by <code>wasm-pack</code>) is not automatically
supported since, from the target name alone, we cannot deduce which
JavaScript interface is in use (or if JavaScript is available at all).</p>
<p>Instead, <em>if the <code>js</code> Cargo feature is enabled</em>, this crate will assume
that you are building for an environment containing JavaScript, and will
call the appropriate methods. Both web browser (main window and Web Workers)
and Node.js environments are supported, invoking the methods
<a href="#supported-targets">described above</a> using the <a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a> toolchain.</p>
<p>To enable the <code>js</code> Cargo feature, add the following to the <code>dependencies</code>
section in your <code>Cargo.toml</code> file:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
getrandom = { version = &quot;0.2&quot;, features = [&quot;js&quot;] }
</code></pre></div>
<p>This can be done even if <code>getrandom</code> is not a direct dependency. Cargo
allows crates to enable features for indirect dependencies.</p>
<p>This feature should only be enabled for binary, test, or benchmark crates.
Library crates should generally not enable this feature, leaving such a
decision to <em>users</em> of their library. Also, libraries should not introduce
their own <code>js</code> features <em>just</em> to enable <code>getrandom</code>’s <code>js</code> feature.</p>
<p>This feature has no effect on targets other than <code>wasm32-unknown-unknown</code>.</p>
<h5 id="nodejs-es-module-support"><a href="#nodejs-es-module-support">Node.js ES module support</a></h5>
<p>Node.js supports both <a href="https://nodejs.org/api/modules.html">CommonJS modules</a> and <a href="https://nodejs.org/api/esm.html">ES modules</a>. Due to
limitations in wasm-bindgen’s <a href="https://rustwasm.github.io/wasm-bindgen/reference/attributes/on-js-imports/module.html"><code>module</code></a> support, we cannot directly
support ES Modules running on Node.js. However, on Node v15 and later, the
module author can add a simple shim to support the Web Cryptography API:</p>
<div class="example-wrap"><pre class="language-js"><code>import { webcrypto } from &#39;node:crypto&#39;
globalThis.crypto = webcrypto
</code></pre></div>
<p>This crate will then use the provided <code>webcrypto</code> implementation.</p>
<h4 id="custom-implementations"><a href="#custom-implementations">Custom implementations</a></h4>
<p>The [<code>register_custom_getrandom!</code>] macro allows a user to mark their own
function as the backing implementation for <a href="fn.getrandom.html" title="fn getrandom::getrandom"><code>getrandom</code></a>. See the macro’s
documentation for more information about writing and registering your own
custom implementations.</p>
<p>Note that registering a custom implementation only has an effect on targets
that would otherwise not compile. Any supported targets (including those
using <code>rdrand</code> and <code>js</code> Cargo features) continue using their normal
implementations even if a function is registered.</p>
<h3 id="early-boot"><a href="#early-boot">Early boot</a></h3>
<p>Sometimes, early in the boot process, the OS has not collected enough
entropy to securely seed its RNG. This is especially common on virtual
machines, where standard “random” events are hard to come by.</p>
<p>Some operating system interfaces always block until the RNG is securely
seeded. This can take anywhere from a few seconds to more than a minute.
A few (Linux, NetBSD and Solaris) offer a choice between blocking and
getting an error; in these cases, we always choose to block.</p>
<p>On Linux (when the <code>getrandom</code> system call is not available), reading from
<code>/dev/urandom</code> never blocks, even when the OS hasn’t collected enough
entropy yet. To avoid returning low-entropy bytes, we first poll
<code>/dev/random</code> and only switch to <code>/dev/urandom</code> once this has succeeded.</p>
<p>On OpenBSD, this kind of entropy accounting isn’t available, and on
NetBSD, blocking on it is discouraged. On these platforms, nonblocking
interfaces are used, even when reliable entropy may not be available.
On the platforms where it is used, the reliability of entropy accounting
itself isn’t free from controversy. This library provides randomness
sourced according to the platform’s best practices, but each platform has
its own limits on the grade of randomness it can promise in environments
with few sources of entropy.</p>
<h3 id="error-handling"><a href="#error-handling">Error handling</a></h3>
<p>We always choose failure over returning known insecure “random” bytes. In
general, on supported platforms, failure is highly unlikely, though not
impossible. If an error does occur, then it is likely that it will occur
on every call to <code>getrandom</code>, hence after the first successful call one
can be reasonably confident that no errors will occur.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Error.html" title="struct getrandom::Error">Error</a></div><div class="desc docblock-short">A small and <code>no_std</code> compatible error type</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.getrandom.html" title="fn getrandom::getrandom">getrandom</a></div><div class="desc docblock-short">Fill <code>dest</code> with random bytes from the system’s preferred random number
source.</div></li><li><div class="item-name"><a class="fn" href="fn.getrandom_uninit.html" title="fn getrandom::getrandom_uninit">getrandom_uninit</a></div><div class="desc docblock-short">Version of the <code>getrandom</code> function which fills <code>dest</code> with random bytes
returns a mutable reference to those bytes.</div></li></ul></section></div></main></body></html>