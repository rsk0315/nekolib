<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Provides a regex matcher that composes several other regex matchers automatically."><title>regex_automata::meta - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-5bc39a1768837dd0.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="regex_automata" data-themes="" data-resource-suffix="" data-rustdoc-version="1.78.0-nightly (ee9c7c940 2024-02-14)" data-channel="nightly" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-4c98445ec4002617.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

<style>
  code.code-math {
      background-color: transparent;
  }
</style>

<script>
  'use strict';

  const macros = {
    // '\\foo': '42',
    // '\\bar': '\\operatorname{bar}^{#1}',
    '\\halfopen': '[#1, #2)',
    '\\floor': '\\lfloor #1\\rfloor',
    '\\ceil': '\\lceil #1\\rceil',
    '\\rounded': '\\lfloor #1\\rceil',
    '\\Floor': '\\left\\lfloor #1\\right\\rfloor',
    '\\Ceil': '\\left\\lceil #1\\right\\rceil',
    '\\Rounded': '\\left\\lfloor #1\\right\\rceil',
    '\\angled': '\\langle #1\\rangle',
    '\\Angled': '\\left\\langle #1\\right\\rangle',
    '\\lcm': '\\operatorname*{lcm}',
    '\\gcd': '\\operatorname*{gcd}',
    '\\poly': '\\operatorname{poly}',
    '\\polylog': '\\operatorname{polylog}',
    '\\concat': '\\mathrel{+\\!\\!+}',
    '\\mex': '\\operatorname*{mex}',
    '\\qed': '\\square',
    '\\Q': '\\mathbb{Q}',
    '\\dd': '\\mathrm{d}',
    '\\ForallL': '{}^{\\forall}#1.\\:#2',
    '\\Forall': '{}^{\\forall}#1.\\,\\left[#2\\right]',
    '\\ExistsL': '{}^{\\exists}#1.\\:#2',
    '\\Exists': '{}^{\\exists}#1.\\,\\left[#2\\right]',
    '\\roundp': '(\\kern-.2em[#1]\\kern-.2em)',
    '\\bigroundp': '\\big(\\kern-.25em\\big[#1\\big]\\kern-.25em\\big)',
    '\\Bigroundp': '\\Big(\\kern-.3em\\Big[#1\\Big]\\kern-.3em\\Big)',
    '\\biggroundp': '\\bigg(\\kern-.3em\\bigg[#1\\bigg]\\kern-.3em\\bigg)',
    '\\Biggroundp': '\\Bigg(\\kern-.35em\\Bigg[#1\\Bigg]\\kern-.35em\\Bigg)',
    '\\hfloor': '\\lfloor\\hspace{-.25em}\\lfloor#1\\rfloor\\hspace{-.25em}\\rfloor',
    '\\xgets': '\\xleftarrow{#1}',
    '\\eod': '\\blacksquare', // end of \<details\>
    '\\lldot': '\\mathop{.\\,.}',
    '\\dp': '\\mathrm{dp}',
  };

  document.addEventListener('DOMContentLoaded', () => {
    const maths = document.getElementsByClassName('language-math');
    for (const elt of maths) {
      katex.render(elt.innerText, elt, { displayMode: true, macros });
    }

    const codes = Array.from(document.getElementsByTagName('code'));
    for (const elt of codes) {
      if (elt.classList.contains('language-math')) continue;
      if (elt.classList.contains('language-inline-math')) {
        katex.render(elt.innerText, elt, { macros });
        continue;
      }

      const parent = elt.parentNode;
      if (parent.nodeName.toLowerCase() === 'pre') {
        continue;
      }

      parent.style.overflowX = 'unset';
      const content = parent.outerHTML.replaceAll(
        /\$<code>([^<]*?)<\/code>\$/g,
        ((match, inner) => {
          return `<code class="code-math">${katex.renderToString(inner, { macros })}</code>`;
        }),
      );

      try {
        parent.outerHTML = content;
      } catch (DOMException) {
        continue;
      }
    }
  });
</script>

<script>
  'use strict';

  const cratesLs = {
    "algo": [
      "bisect",
      "tortoise_hare"
    ],
    "corro": [
      "borrow"
    ],
    "discussion": [
      "dp",
      "plane-sweep"
    ],
    "ds": [
      "foldable_deque",
      "foldable_queue",
      "rs01_dict",
      "union-find",
      "vec_segtree"
    ],
    "fmt": [
      "str_sep",
      "yes_no"
    ],
    "graph": [
      "bfs01",
      "dijkstra"
    ],
    "inner": [],
    "integer": [
      "bin_iter",
      "pdep_pext"
    ],
    "io": [
      "input",
      "readable"
    ],
    "macros": [],
    "math": [
      "divisors",
      "factors",
      "linear_sieve",
      "modint"
    ],
    "naive": [
      "assoc-list",
      "concat-monoid",
      "disjoint-set",
      "rs01_dict"
    ],
    "ops": [
      "monoid",
      "op_add",
      "usize_bounds"
    ],
    "poc": [
      "katex-support"
    ],
    "random": [
      "randgen"
    ],
    "seq": [
      "inversion",
      "lis",
      "majority_vote",
      "suffix_array"
    ],
    "snippet": [
      "proconio"
    ],
    "uslice": [
      "bucket_sort",
      "permutation"
    ]
  };

  document.addEventListener('DOMContentLoaded', () => {
    const crates = [...document.getElementsByClassName('block crate')][0];

    const links = new Map([...crates.querySelectorAll('a')].map((e) => [
      e.innerText,
      {
        name: e.innerText,
        href: e.href,
        current: e.parentNode.classList.contains('current'),
      },
    ]));

    const tree = new Map();
    for (const mod of Object.keys(cratesLs)) {
      for (const crate of cratesLs[mod]) {
        const crate_ = crate.replaceAll('-', '_');
        if (!links.has(crate_)) continue;

        if (!tree.has(mod)) {
          tree.set(mod, []);
        }

        tree.get(mod).push(links.get(crate_));
      }
    }

    const cratesElt = document.createElement('ul');
    cratesElt.classList.add('block');
    cratesElt.classList.add('crate');
    for (const [modName, mod] of tree) {
      {
        const li = document.createElement('li');
        const a = document.createElement('a');
        const link = links.get(modName);
        a.href = link.href;
        if (link.current) li.classList.add('current');
        a.innerText = link.name;
        li.appendChild(a);
        cratesElt.appendChild(li);
      }

      const ul = document.createElement('ul');
      for (const crate of mod) {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = crate.href;
        if (crate.current) li.classList.add('current');
        a.innerText = crate.name;
        li.appendChild(a);
        ul.appendChild(li);
      }
      cratesElt.appendChild(ul);
    }

    crates.outerHTML = cratesElt.outerHTML;
  });
</script>

</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../regex_automata/index.html">regex_automata</a><span class="version">0.4.5</span></h2></div><h2 class="location"><a href="#">Module meta</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section><h2><a href="../index.html">In crate regex_automata</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../regex_automata/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">regex_automata</a>::<wbr><a class="mod" href="#">meta</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/regex_automata/meta/mod.rs.html#1-62">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Provides a regex matcher that composes several other regex matchers
automatically.</p>
<p>This module is home to a meta <a href="struct.Regex.html" title="struct regex_automata::meta::Regex"><code>Regex</code></a>, which provides a convenient high
level API for executing regular expressions in linear time.</p>
<h2 id="comparison-with-the-regex-crate"><a class="doc-anchor" href="#comparison-with-the-regex-crate">§</a>Comparison with the <code>regex</code> crate</h2>
<p>A meta <code>Regex</code> is the implementation used directly by the <code>regex</code> crate.
Indeed, the <code>regex</code> crate API is essentially just a light wrapper over a meta
<code>Regex</code>. This means that if you need the full flexibility offered by this
API, then you should be able to switch to using this API directly without
any changes in match semantics or syntax. However, there are some API level
differences:</p>
<ul>
<li>The <code>regex</code> crate API returns match objects that include references to the
haystack itself, which in turn makes it easy to access the matching strings
without having to slice the haystack yourself. In contrast, a meta <code>Regex</code>
returns match objects that only have offsets in them.</li>
<li>At time of writing, a meta <code>Regex</code> doesn’t have some of the convenience
routines that the <code>regex</code> crate has, such as replacements. Note though that
<a href="../util/captures/struct.Captures.html#method.interpolate_string" title="method regex_automata::util::captures::Captures::interpolate_string"><code>Captures::interpolate_string</code></a>
will handle the replacement string interpolation for you.</li>
<li>A meta <code>Regex</code> supports the <a href="../struct.Input.html" title="struct regex_automata::Input"><code>Input</code></a> abstraction, which
provides a way to configure a search in more ways than is supported by the
<code>regex</code> crate. For example, <a href="../struct.Input.html#method.anchored" title="method regex_automata::Input::anchored"><code>Input::anchored</code></a> can
be used to run an anchored search, regardless of whether the pattern is itself
anchored with a <code>^</code>.</li>
<li>A meta <code>Regex</code> supports multi-pattern searching everywhere.
Indeed, every <a href="../struct.Match.html" title="struct regex_automata::Match"><code>Match</code></a> returned by the search APIs
include a <a href="../struct.PatternID.html" title="struct regex_automata::PatternID"><code>PatternID</code></a> indicating which pattern
matched. In the single pattern case, all matches correspond to
<a href="../struct.PatternID.html#associatedconstant.ZERO" title="associated constant regex_automata::PatternID::ZERO"><code>PatternID::ZERO</code></a>. In contrast, the <code>regex</code> crate
has distinct <code>Regex</code> and a <code>RegexSet</code> APIs. The former only supports a single
pattern, while the latter supports multiple patterns but cannot report the
offsets of a match.</li>
<li>A meta <code>Regex</code> provides the explicit capability of bypassing its internal
memory pool for automatically acquiring mutable scratch space required by its
internal regex engines. Namely, a <a href="struct.Cache.html" title="struct regex_automata::meta::Cache"><code>Cache</code></a> can be explicitly provided to lower
level routines such as <a href="struct.Regex.html#method.search_with" title="method regex_automata::meta::Regex::search_with"><code>Regex::search_with</code></a>.</li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.BuildError.html" title="struct regex_automata::meta::BuildError">BuildError</a></div><div class="desc docblock-short">An error that occurs when construction of a <code>Regex</code> fails.</div></li><li><div class="item-name"><a class="struct" href="struct.Builder.html" title="struct regex_automata::meta::Builder">Builder</a></div><div class="desc docblock-short">A builder for configuring and constructing a <code>Regex</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.Cache.html" title="struct regex_automata::meta::Cache">Cache</a></div><div class="desc docblock-short">Represents mutable scratch space used by regex engines during a search.</div></li><li><div class="item-name"><a class="struct" href="struct.CapturesMatches.html" title="struct regex_automata::meta::CapturesMatches">CapturesMatches</a></div><div class="desc docblock-short">An iterator over all non-overlapping leftmost matches with their capturing
groups.</div></li><li><div class="item-name"><a class="struct" href="struct.Config.html" title="struct regex_automata::meta::Config">Config</a></div><div class="desc docblock-short">An object describing the configuration of a <code>Regex</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.FindMatches.html" title="struct regex_automata::meta::FindMatches">FindMatches</a></div><div class="desc docblock-short">An iterator over all non-overlapping matches.</div></li><li><div class="item-name"><a class="struct" href="struct.Regex.html" title="struct regex_automata::meta::Regex">Regex</a></div><div class="desc docblock-short">A regex matcher that works by composing several other regex matchers
automatically.</div></li><li><div class="item-name"><a class="struct" href="struct.Split.html" title="struct regex_automata::meta::Split">Split</a></div><div class="desc docblock-short">Yields all substrings delimited by a regular expression match.</div></li><li><div class="item-name"><a class="struct" href="struct.SplitN.html" title="struct regex_automata::meta::SplitN">SplitN</a></div><div class="desc docblock-short">Yields at most <code>N</code> spans delimited by a regular expression match.</div></li></ul></section></div></main></body></html>